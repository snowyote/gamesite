{
  "name": "mocha-as-promised",
  "description": "Adds “thenable” promise support to the Mocha test runner.",
  "version": "1.2.1",
  "author": {
    "name": "Domenic Denicola",
    "email": "domenic@domenicdenicola.com",
    "url": "http://domenicdenicola.com"
  },
  "license": "WTFPL",
  "repository": {
    "type": "git",
    "url": "https://github.com/domenic/mocha-as-promised"
  },
  "bugs": {
    "url": "http://github.com/domenic/mocha-as-promised/issues"
  },
  "main": "mocha-as-promised.js",
  "scripts": {
    "test": "mocha",
    "test-browser": "opener ./test/index.html",
    "lint": "jshint mocha-as-promised.js"
  },
  "devDependencies": {
    "coffee-script": ">= 1.4.0",
    "chai": ">= 1.4.0",
    "chai-as-promised": ">= 3.2.3",
    "jshint": ">= 0.9.1",
    "mocha": ">= 1.8.0",
    "opener": ">= 1.3.0",
    "q": ">= 0.8.11"
  },
  "readme": "# Promise-Returning Tests for Mocha\r\n\r\nSo you really like [Mocha][]. But you also really like [promises][]. And you'd like to see\r\n[support in Mocha][mocha-issue] for the promise-returning test style found in [Buster][] and others, i.e. stuff like\r\n\r\n```js\r\nit(\"should be fulfilled with 5\", function () {\r\n    return promise.then(function (result) {\r\n        return result.should.equal(5);\r\n    });\r\n});\r\n```\r\n\r\nOr even better, if you are using [Chai as Promised][],\r\n\r\n```js\r\nit(\"should be fulfilled with 5\", function () {\r\n    return promise.should.become(5);\r\n});\r\n```\r\n\r\nUntil now you've been making do with [hacks][], or perhaps using [my fork of Mocha][mocha-fork], and hoping I rebase\r\noften enough to keep things nice. But now, with Mocha as Promised, you have a much nicer option available!\r\n\r\n## How to Use\r\n\r\nOnce you install and set up Mocha as Promised, you now have a second way of creating asynchronous tests, besides Mocha's\r\nusual `done`-callback style. Just return a promise: if it is fulfilled, the test passes, and if it is rejected, the test\r\nfails, with the rejection reason as the error. Nice, huh?\r\n\r\nIf you want to do multiple assertions in a single test, first, think carefully about whether you should instead break\r\nthat test up into multiple tests. Once you've decided that yes, you're really OK with multiple assertions, then you'll\r\nwant to use a promise-aggregator function, like [Q][]'s [`Q.all`][Q.all]:\r\n\r\n```js\r\nit(\"should be fulfilled with an object with the correct properties\", function () {\r\n    var userPromise = getUserAsynchronously();\r\n\r\n    return Q.all([\r\n        userPromise.should.eventually.be.an(\"object\"),\r\n        userPromise.should.eventually.have.property(\"id\", 123),\r\n        userPromise.should.eventually.have.property(\"firstName\", \"Domenic\"),\r\n        userPromise.should.eventually.have.property(\"lastName\", \"Denicola\")\r\n    ]);\r\n});\r\n```\r\n\r\n(Once again I'll plug my [Chai as Promised][] library, so you can do super-awesome “eventual” assertions like these.)\r\n\r\nMoch as Promised works with all Mocha interfaces: BDD, TDD, QUnit, whatever. It hooks in at such a low level, the\r\ninterfaces don't even get involved.\r\n\r\n## Installation and Usage\r\n\r\n### Node\r\n\r\nDo an `npm install mocha-as-promised` to get up and running. Then:\r\n\r\n```javascript\r\nrequire(\"mocha-as-promised\")();\r\n```\r\n\r\nYou can of course put this code in a common test fixture file; for an example, see\r\n[the Mocha as Promised tests themselves][fixturedemo].\r\n\r\n### AMD\r\n\r\nMocha as Promised supports being used as an [AMD][amd] module, registering itself anonymously. So, assuming you have\r\nconfigured your loader to map the Mocha and Mocha as Promised files to the respective module IDs `\"mocha\"` and\r\n`\"mocha-as-promised\"`, you can use them as follows:\r\n\r\n```javascript\r\ndefine(function (require, exports, module) {\r\n    var mocha = require(\"mocha\");\r\n    var mochaAsPromised = require(\"mocha-as-promised\");\r\n\r\n    mochaAsPromised(mocha);\r\n});\r\n```\r\n\r\n### `<script>` tag\r\n\r\nIf you include Mocha as Promised directly with a `<script>` tag, after the one for Mocha itself, then it will\r\nautomatically plug in to Mocha and be ready for use:\r\n\r\n```html\r\n<script src=\"mocha.js\"></script>\r\n<script src=\"mocha-as-promised.js\"></script>\r\n```\r\n\r\n## How Does This Work!?\r\n\r\n**Black magic**. No, seriously, this is a big hack.\r\n\r\nThe essential strategy is to intercept any test functions that Mocha runs, and inspect their return values. If they\r\nreturn a promise, then translate fulfillment/rejection appropriately. It's explained in more detail how exactly this is\r\ndone in a large comment block at the top of the source. You can also check out d98f2d95197896cd7b948b6208cb6c1235f43eed\r\nfor an alternative approach at the interception, which was abandoned in favor of the current one.\r\n\r\nNote that Mocha as Promised *doesn't* just override `Runnable.prototype.run`, as is done by [my Mocha fork][mocha-fork].\r\nThat seemed a bit too fragile to be a long-term solution. The interception approach involves more black magic, but\r\nis probably more resilient in the face of upstream changes. At least, that's the hope.\r\n\r\n\r\n[Mocha]: http://visionmedia.github.com/mocha/\r\n[promises]: http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript\r\n[Buster]: http://busterjs.org/\r\n[mocha-issue]: https://github.com/visionmedia/mocha/pull/329\r\n[Chai as Promised]: https://github.com/domenic/chai-as-promised/\r\n[hacks]: https://github.com/domenic/chai-as-promised/#working-with-non-promise%E2%80%93friendly-test-runners\r\n[mocha-fork]: https://github.com/domenic/mocha/tree/promises\r\n[Q]: https://github.com/kriskowal/q\r\n[Q.all]: https://github.com/kriskowal/q#combination\r\n[fixturedemo]: https://github.com/domenic/mocha-as-promised/tree/master/test/\r\n[amd]: https://github.com/amdjs/amdjs-api/wiki/AMD\r\n",
  "readmeFilename": "README.md",
  "_id": "mocha-as-promised@1.2.1",
  "_from": "mocha-as-promised@1.2.x"
}
